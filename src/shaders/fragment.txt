#version 330 core

out vec4 screenColor;

// camera
uniform vec3 eye;
uniform vec2 screen_size;
uniform float L, R, B, T, N;

// plane
uniform vec3 planePoint;
uniform vec3 planeNormal;
uniform vec3 planeColor;

//sphere
uniform vec3 sphereCenter;
uniform float sphereRadius;
uniform vec3 sphereColor;

//cylinder
uniform vec3 cylinderCenter;
uniform float cylinderRadius;
uniform float cylinderHeight;
uniform vec3 cylinderColor;

//cube
uniform vec3 cubeCenter;
uniform float cubeLength;
uniform vec3 cubeColor;


uniform vec3 light_source;


const vec3 MATERIAL = vec3(0.4, 0.6, 0.6);
const float SHININESS = 100.0;


float planeIntersect(vec3 rayOrigin, vec3 rayDir, vec3 point, vec3 normal);
vec3 phong(float t, vec3 eye, vec3 direction, vec3 normal, vec3 color);
float sphereIntersect(vec3 rayOrigin, vec3 rayDir, vec3 center, float r);
float shadow(vec3 hit, vec3 normal);
float cylinderIntersect(vec3 rayOrigin, vec3 dir, vec3 center, float r, float h);
float cubeIntersect(vec3 rayOrigin, vec3 rayDir, vec3 cubeCenter, float cubeLength);
vec3 cubeNormal(vec3 hit, vec3 center, float l);

void main() {
    screenColor = vec4(1.0, 0.0, 0.0, 1.0);
    float pixelX = gl_FragCoord.x;
    float pixelY = gl_FragCoord.y;

    float stepX = (R - L) / screen_size.x;
    float stepY = (T - B) / screen_size.y;
    
    float x = L + stepX * (pixelX + 0.5);
    float y = B + stepY * (pixelY + 0.5);
    
    vec3 pixelCenter = vec3(x, y, N);
    vec3 direction = normalize(pixelCenter - eye);
    

    float tPlane = planeIntersect(eye, direction, planePoint, planeNormal);
    float tSphere = sphereIntersect(eye, direction, sphereCenter, sphereRadius);
    float tcylinder = cylinderIntersect(eye,direction, cylinderCenter, cylinderRadius, cylinderHeight);
    float tcube = cubeIntersect(eye,direction, cubeCenter, cubeLength);

    float tMin = -1.0;
    int hitShape = -1;  // 0=plane, 1=sphere, 2=cylinder, 3=cube

    if (tPlane > 0.0) { tMin = tPlane; hitShape = 0; }
    if (tSphere > 0.0 && (tMin < 0.0 || tSphere < tMin)) { tMin = tSphere; hitShape = 1; }
    if (tcylinder > 0.0 && (tMin < 0.0 || tcylinder < tMin)) { tMin = tcylinder; hitShape = 2; }
    if (tcube > 0.0 && (tMin < 0.0 || tcube < tMin)) { tMin = tcube; hitShape = 3; }

    if (hitShape == 1) {
        // sphere
        vec3 hitPoint = eye + tSphere * direction;
        vec3 normal = normalize(hitPoint - sphereCenter);
        screenColor = vec4(phong(tSphere, eye, direction, normal, sphereColor), 1.0);
    } else if (hitShape == 2) {
        // cylinder
        vec3 hitPoint = eye + tcylinder * direction;
        vec3 normal = hitPoint - cylinderCenter;
        normal.y = 0.0;
        normal = normalize(normal);
        screenColor = vec4(phong(tcylinder, eye, direction, normal, cylinderColor), 1.0);
    } else if (hitShape == 3) {
        // cube
        vec3 hitPoint = eye + tcube * direction;
        vec3 normal = cubeNormal(hitPoint, cubeCenter, cubeLength);
        screenColor = vec4(phong(tcube, eye, direction, normal, cubeColor), 1.0);
    } else if (hitShape == 0) {
        // plane
        vec3 hitPoint = eye + tPlane * direction;
        float shadowFactor = shadow(hitPoint, planeNormal);
        vec3 color = phong(tPlane, eye, direction, planeNormal, planeColor) * shadowFactor;
        screenColor = vec4(color, 1.0);
    } else {
        screenColor = vec4(0.0, 0.0, 0.0, 1.0);
    }
}

float shadow(vec3 hit, vec3 normal) {
    vec3 toLight = normalize(light_source - hit);
    vec3 offsetHit = hit + normal * 0.001;  // small offset to avoid self-intersection
    
    float t = sphereIntersect(offsetHit, toLight, sphereCenter, sphereRadius);
    
    if (t > 0.0) {
        return 0.5;  // in shadow
    }
    return 1.0;  // fully lit
}


float planeIntersect(vec3 rayOrigin, vec3 rayDir, vec3 point, vec3 normal) {
    float denom = dot(normal, rayDir);
    
    if (abs(denom) < 0.0001) {
        return -1.0;
    }
    
    vec3 F = point - rayOrigin;
    float t = dot(F, normal) / denom;
    
    return t;
}


float sphereIntersect(vec3 rayOrigin, vec3 rayDir, vec3 center, float r){
    vec3 origin = rayOrigin - center;

    float a=1; 
    float b= 2.0 * dot(rayDir, origin);
    float rSQ= r * r; 
    float c = dot(origin, origin) - rSQ;
    float discriminant = (b * b) - (4 * a * c);

    if(discriminant < 0){
        return 0; 
    }
    else{
        float t1 = ((-b) - sqrt(discriminant)) / (2 * a);
        float t2 = ((-b) + sqrt(discriminant)) / (2 * a);

        if (t1 > 0.0) return t1;  // nearest hit
        if (t2 > 0.0) return t2;  // inside sphere, exiting
        return -1.0;   

    }
}

vec3 cubeNormal(vec3 hit, vec3 center, float l) {
    vec3 localHit = hit - center;
    vec3 halfSize = vec3(l / 2.0);
    
    // Find which axis we're farthest on (that's the face we hit)
    vec3 d = abs(localHit) / halfSize;
    
    if (d.x > d.y && d.x > d.z) {
        return vec3(sign(localHit.x), 0.0, 0.0);
    } else if (d.y > d.z) {
        return vec3(0.0, sign(localHit.y), 0.0);
    } else {
        return vec3(0.0, 0.0, sign(localHit.z));
    }
}


float cylinderIntersect(vec3 rayOrigin, vec3 dir, vec3 center, float r, float h){
    vec3 origin= rayOrigin - center;

    float a = (dir.x * dir.x) + (dir.z * dir.z);
    float b = 2 * ( origin.x * dir.x + origin.z * dir.z);
    float rSQ = r * r;
    float c = origin.x * origin.x + origin.z * origin.z - rSQ;

    float discriminant = b * b -4 * a * c;

    if(discriminant < 0){
        return 0;
    }
    else{
        float dSR = sqrt(discriminant);
        
        float t1 = ((-b) - sqrt(discriminant)) / (2 * a);
        float t2 = ((-b) + sqrt(discriminant)) / (2 * a);

        float y1 = (rayOrigin.y) + t1 * dir.y;
        float y2 = (rayOrigin.y) + t2 * dir.y;

        float bottom = center.y -h/2;
        float top = center.y + h/2;

        if( (y1>= bottom && y1 <=top) || (y2 >=bottom && y2 <=top )){
            if (t1 > 0.0) return t1;  // nearest hit
            if (t2 > 0.0) return t2;  // inside sphere, exiting
        }
        else{
            return -1;
        }

    }

    return -1;

}

float cubeIntersect(vec3 rayOrigin, vec3 rayDir, vec3 center, float l){
    vec3 origin = rayOrigin - center;
    vec3 cubeShape= vec3(l /2, l/2, l/2);

    vec3 cmin = center - cubeShape;
    vec3 cmax = center + cubeShape;

    vec3 tmin = cmin - rayOrigin;
    tmin = tmin / rayDir;

    vec3 tmax = cmax - rayOrigin;
    tmax = tmax / rayDir;

    float t1 = max(max(min(tmin.x, tmax.x), min(tmin.y, tmax.y)), min(tmin.z, tmax.z));
    float t2 = min(min(max(tmin.x, tmax.x), max(tmin.y, tmax.y)), max(tmin.z, tmax.z));

    if (t1 <= t2 && t2 > 0.0){
        if(t1> 0.0) return t1;
        return t2;

    }
    return -1;

}



vec3 phong(float t, vec3 eye, vec3 direction, vec3 normal, vec3 color){

    vec3 hit = eye + t * direction;

    vec3 N = normal;
    vec3 L = normalize(light_source - hit);
    vec3 V = normalize(eye - hit);
    vec3 R = reflect(-L, N);

    vec3 ambient = MATERIAL.x * color;

    float dotNL = max(dot(normal, L), 0.0);
    vec3 diffuse = MATERIAL.y* dotNL * color; 


    float dotRV= max(dot(R,V), 0.0);
    vec3 specular = MATERIAL.z * pow(dotRV, SHININESS) * color;

    return ambient + diffuse + specular;

}